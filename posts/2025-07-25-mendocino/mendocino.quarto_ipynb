{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: The Era of Mega-Fires\n",
        "description: Examining Fire Severity and Land Cover After the 2018 Mendocino Complex Fire\n",
        "author:\n",
        "  - name: Haylee Oyler\n",
        "    url: https://haylee360.github.io/\n",
        "    orcid: 0009-0008-2133-3708\n",
        "date: '2025-07-25'\n",
        "categories:\n",
        "  - Remote Sensing\n",
        "  - Python\n",
        "  - Wildfire\n",
        "toc: true\n",
        "image: images/san-juan-del-piari.jpg\n",
        "citation:\n",
        "  url: https://haylee360.github.io/posts/2025-07-25-mendocino/\n",
        "jupyter: python3\n",
        "execute:\n",
        "  warning: false\n",
        "  message: false\n",
        "---\n",
        "\n",
        "\n",
        "## The 2018 Mendocino Complex Fire\n",
        "\n",
        "Was a [large mega-fire](https://en.wikipedia.org/wiki/Mendocino_Complex_Fire) that occurred in Mendocino County, California. The complex was composed of the River Fire and the Ranch Fire, both of which burned 198 km<sup>2</sup> (48,920 acres) and 1,660 km<sup>2</sup> (410,203 acres) respectively for a total of 1,858 km<sup>2</sup> (459,123 acres) burned. At the time, it was the largest fire in California's recorded history. Fires that exceed 100 km<sup>2</sup> are known as megafires because they greatly surpass the severity and size of historical wildfires. As climate change and land use change intensify wildfire risk, megafires are expected to increase in frequency.\n",
        "\n",
        "This notebook uses a a variety of remotely-sensed data sources to explore the severity and vegetation dynamics of this mega-fire. I chose this region in particular because my first research experience with Dr. Kendall Calhoun and [Dr. Justin Brashares](https://vcresearch.berkeley.edu/faculty/justin-brashares) was conducted in this region at the [Hopland Research and Extension Center](https://ucanr.edu/rec/hopland-research-and-extension-center). We studied the effects of fire on wildlife recovery, specifically using audio monitors to examine the distribution of bird and bat communities across different levels of fire severity and pyrodiversity. The paper on this work can be found [here](https://doi.org/10.1002/ecs2.70263).\n",
        "\n",
        "### Overview\n",
        "\n",
        "This code will use the Mendocino Complex Fire as a case study to explore different metrics of fire severity, recovery, and projected risk. Specifically, it uses:\n",
        "\n",
        "- Landsat data to visualize true and false color imagery of the fire scar and the relative burn ratio \n",
        "- Land use and land cover data from the USGS to calculate land cover statistics within the fire perimeter boundaries\n",
        "- Downscaled climate projection data from Cal-Adapt to view wildfire-relevant projected climate variables in California\n",
        "\n",
        "### Data\n",
        "\n",
        "- [CalFire Fire Perimeter Data](https://www.fire.ca.gov/what-we-do/fire-resource-assessment-program/fire-perimeters): The Ranch Fire perimeter data comes from CalFire's data portal. The accessed GeoDatabase includes information on the fire date, managing agency, cause, acres, and the geospatial boundary of the fire, among other information. This data was pre-processed to select only the Ranch fire boundary geometry.\n",
        "\n",
        "- [Landsat Data](https://planetarycomputer.microsoft.com/dataset/landsat-c2-l2): The Landsat data comes from Microsoft's Planetary Computer Data Catalog. It is a simplified collection of bands (red, green, blue, near-infrared and shortwave infrared) from the Landsat Collection 2 Level-2 atmospherically corrected surface reflectance data, collected by the Landsat 8 satellite. \n",
        "\n",
        "- [Land Use and Land Cover Data](https://planetarycomputer.microsoft.com/dataset/gap#overview): The LULC data comes the Gap Collection provided by the United States Geological Survey accessed via Microsoft's Planetary Computer Data Catalog. It is a categorical raster with a 30 m x 30 m pixel resolution representing highly thematically detailed land cover map of the U.S. \n"
      ],
      "id": "7143a2c9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Import packages\"\n",
        "\n",
        "# Import packages\n",
        "import os\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.ticker as mtick\n",
        "import matplotlib.patches as mpatches \n",
        "from matplotlib.patches import Patch\n",
        "from matplotlib.colors import ListedColormap\n",
        "import seaborn as sns\n",
        "import geopandas as gpd\n",
        "import rioxarray as rioxr\n",
        "from shapely import box\n",
        "import rasterio\n",
        "from rasterio.plot import show\n",
        "\n",
        "# MPC \n",
        "import pystac_client\n",
        "import planetary_computer\n",
        "import odc.stac\n",
        "from pystac.extensions.eo import EOExtension as eo"
      ],
      "id": "b1e21e95",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Fire Scar Visualization\n",
        "\n",
        "We'll start by accessing the MPC data catalog to retrieve the Landsat data. We want to narrow down our region of interest to the bounding box of the Ranch Fire, so we'll import the fire perimeter data and extract the necessary coordinates for our query.\n"
      ],
      "id": "232319f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Import Ranch Fire perimeter\n",
        "ranch_fire = gpd.read_file(os.path.join('data', 'ranch_boundary.geojson'))\n",
        "river_fire = gpd.read_file(os.path.join('data', 'river_boundary.geojson'))\n",
        "\n",
        "# Combine the two fire perimeters into one complex fire\n",
        "union_geom = ranch_fire.geometry.union(river_fire.geometry)\n",
        "\n",
        "# Create a new geo dataframe of the combined geometry\n",
        "mendocino = gpd.GeoDataFrame(geometry=[union_geom.unary_union], \n",
        "                            crs=ranch_fire.crs)\n",
        "\n",
        "# Get the bounding box of the entire complex fire\n",
        "mendocino_bbox = list(mendocino.to_crs('epsg:4326').total_bounds)\n",
        "\n",
        "# Set time period of interest\n",
        "time_of_interest = \"2018-10-01/2018-11-01\""
      ],
      "id": "63a83895",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Open MPC data catalog connection\n",
        "catalog = pystac_client.Client.open(\"https://planetarycomputer.microsoft.com/api/stac/v1\", modifier=planetary_computer.sign_inplace)\n",
        "\n",
        "# Search MPC catalog \n",
        "search = catalog.search(collections=['landsat-c2-l2'],\n",
        "                        datetime=time_of_interest,\n",
        "                        bbox=mendocino_bbox,\n",
        "                        query={\n",
        "                            # Images with less than 10% cloud cover\n",
        "                            \"eo:cloud_cover\": {\"lt\": 10},\n",
        "                            # Landsat 8 and 9 were chosen to avoid landsat 7 data collection failure\n",
        "                            \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]}\n",
        "                            }\n",
        "                        )\n",
        "\n",
        "# Retrieve search items\n",
        "items = search.item_collection()\n",
        "print(f\"Returned {len(items)} Items\")"
      ],
      "id": "b47400d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Select the item with the minimum cloud cover\n",
        "selected_item = min(items, key=lambda item: eo.ext(item).cloud_cover)\n",
        "\n",
        "# Display item \n",
        "print(\n",
        "    f\"Choosing {selected_item.id} from {selected_item.datetime.date()}\"\n",
        "    + f\" with {selected_item.properties['eo:cloud_cover']}% cloud cover\"\n",
        ")"
      ],
      "id": "e78b8bd9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Select bands of interest for visualization\n",
        "bands_of_interest = [\"nir08\", \"red\", \"green\", \"blue\", \"swir16\", \"swir22\"]\n",
        "\n",
        "# Load in the data from the stac item\n",
        "post_burn_data = odc.stac.stac_load(\n",
        "    [selected_item], bands=bands_of_interest, bbox=mendocino_bbox\n",
        ").isel(time=0)\n",
        "\n",
        "# Reproject data to match the CRS between our two datasets\n",
        "mendocino= mendocino.to_crs(\"EPSG:4326\")\n",
        "post_burn_data = post_burn_data.rio.reproject(\"EPSG:4326\")\n",
        "\n",
        "# Confirm that the CRS of our data match\n",
        "assert post_burn_data.rio.crs == mendocino.crs"
      ],
      "id": "46c25cfe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that our data input and output is complete, we'll create a simple map of the true color and false color imagery of the fire scar\n"
      ],
      "id": "f1419956"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Reveal code\"\n",
        "\n",
        "fig, axes = plt.subplots(1, 2, figsize=(15, 7))\n",
        "\n",
        "# True color image\n",
        "post_burn_data[[\"red\", \"green\", \"blue\"]].to_array().plot.imshow(robust=True, ax=axes[0])\n",
        "\n",
        "# Set titles and labels\n",
        "axes[0].set_title(\"True Color Image\\n2018 Mendocino Complex Fire, Mendocino County, CA\", fontsize=13)\n",
        "axes[0].set_xlabel('Longitude (degrees)')\n",
        "axes[0].set_ylabel('Latitude (degrees)')\n",
        "\n",
        "# False color image\n",
        "post_burn_data[['swir22', 'nir08', 'red']].to_array().plot.imshow(ax=axes[1], robust=True)\n",
        "\n",
        "# Create a legend for the bands and boundary\n",
        "legend_swir = mpatches.Patch(color=\"#eb4b4b\", label='Shortwave Infrared\\n- Burned Area')\n",
        "legend_nir = mpatches.Patch(color=\"#a1fc81\", label='Near Infrared\\n- Vegetation')\n",
        "\n",
        "# Add legend to false color subplot\n",
        "axes[1].legend(handles=[legend_swir, legend_nir], \n",
        "                bbox_to_anchor=(1.32, 1), \n",
        "                fontsize=10)\n",
        "\n",
        "# Set title and labels\n",
        "axes[1].set_title('False Color Image\\n 2018 Mendocino Complex Fire, Mendocino County, CA', fontsize=13)\n",
        "axes[1].set_xlabel('Longitude (degrees)')\n",
        "axes[1].set_ylabel('')\n",
        "axes[1].set_yticklabels('')\n",
        "axes[1].set_yticks([])\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "c269628d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Fire Severity: NBR and RBR\n",
        "\n",
        "While images like the ones above are a great starting point for visualizing fire severity, there are many other ways to understand changing land cover as a result of fire. Two common ones are the [normalized burn ratio](https://un-spider.org/advisory-support/recommended-practices/recommended-practice-burn-severity/in-detail/normalized-burn-ratio) and the [relative burn ratio](https://www.mdpi.com/2072-4292/6/3/1827). The normalized burn ratio uses the spectral reflectance of healthy and burned vegetation to identify areas of high severity fire. Near infrared radiation ($NIR$) is highly reflective in healthy vegetation and short wave infrared ($SWIR$) is highly reflective in unhealthy or burned vegetation.\n",
        "\n",
        "$$ NBR = \\frac{NIR - SWIR}{NIR + SWIR} $$\n",
        "\n",
        "The relative burn ratio is an alternate way to visualize fire severity that takes into account the overall variation in vegetation before the fire event. Scaling by pre-fire conditions allows you to compare vegetation loss across different intital vegetation conditions. Here's how it is described in [Parks et al. 2014](https://www.mdpi.com/2072-4292/6/3/1827):\"*Simply put, RBR is the dNBR divided by a simple adjustment to the pre-fire NBR. Adding 1.001 to the denominator ensures that the denominator will never be zero, thereby preventing the equation from reaching infinity and failing.*\"\n",
        "\n",
        "$$ RBR = \\frac{\\delta NBR}{NBR_{prefire} + 1.001} $$\n",
        "\n",
        "For this visualization, I will be creating a map of $RBR$ for the Ranch Fire. To do this, will need to get data before the fire event to analyze pre-fire conditions. \n"
      ],
      "id": "758472ee"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Change our time period of interest to before the fire\n",
        "time_of_interest = \"2018-01-01/2018-07-01\"\n",
        "\n",
        "# Search MPC catalog \n",
        "search = catalog.search(collections=['landsat-c2-l2'],\n",
        "                        datetime=time_of_interest,\n",
        "                        bbox=mendocino_bbox,\n",
        "                        query={\n",
        "                            # Images with less than 10% cloud cover\n",
        "                            \"eo:cloud_cover\": {\"lt\": 10},\n",
        "                            # Landsat 8 and 9 were chosen to avoid landsat 7 data collection failure\n",
        "                            \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]}\n",
        "                            }\n",
        "                        )\n",
        "\n",
        "# Retrieve search items\n",
        "items = search.item_collection()\n",
        "print(f\"Returned {len(items)} Items\")\n",
        "\n",
        "# Select the item with the minimum cloud cover\n",
        "pre_burn_item = min(items, key=lambda item: eo.ext(item).cloud_cover)\n",
        "\n",
        "print(\n",
        "    f\"Choosing {pre_burn_item.id} from {pre_burn_item.datetime.date()}\"\n",
        "    + f\" with {pre_burn_item.properties['eo:cloud_cover']}% cloud cover\"\n",
        ")\n",
        "\n",
        "# Select bands of interest for visualization\n",
        "bands_of_interest = [\"nir08\", \"red\", \"green\", \"blue\", \"swir16\", \"swir22\"]\n",
        "pre_burn_data = odc.stac.stac_load(\n",
        "    [pre_burn_item], bands=bands_of_interest, bbox=mendocino_bbox\n",
        ").isel(time=0)\n",
        "\n",
        "# Confirm CRS matches the post-burn data\n",
        "pre_burn_data = pre_burn_data.rio.reproject(\"EPSG:4326\")\n",
        "assert post_burn_data.rio.crs == pre_burn_data.rio.crs"
      ],
      "id": "dcf0d67d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Pre-burn NBR\n",
        "pre_swir = pre_burn_data[\"swir22\"].astype(\"float\")\n",
        "pre_nir = pre_burn_data[\"nir08\"].astype(\"float\")\n",
        "pre_nbr = (pre_nir - pre_swir) / (pre_nir + pre_swir)\n",
        "\n",
        "# Post-burn NBR\n",
        "post_swir = post_burn_data[\"swir22\"].astype(\"float\")\n",
        "post_nir = post_burn_data[\"nir08\"].astype(\"float\")\n",
        "post_nbr = (post_nir - post_swir) / (post_nir + post_swir)\n",
        "\n",
        "# Difference in NBR\n",
        "dnbr =  pre_nbr - post_nbr\n",
        "\n",
        "# Relative burn ratio\n",
        "rbr = dnbr / (pre_nbr + 1.001)"
      ],
      "id": "959776ab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Reveal code\"\n",
        "\n",
        "# View RBR across the fire scar \n",
        "fig, ax = plt.subplots(figsize=(14, 8))\n",
        "\n",
        "rbr.plot.imshow(ax=ax, cmap=\"plasma_r\",\n",
        "                    cbar_kwargs={\n",
        "                        'label':'RBR',\n",
        "                    })\n",
        "\n",
        "# Plot the fire perimeter\n",
        "mendocino.boundary.plot(ax=ax, edgecolor='#fff', \n",
        "                        linewidth=2, label='Mendocino Complex Fire Boundary')\n",
        "\n",
        "ax.set_title(\"Relative Burn Ratio\\n2018 Mendocino Complex Fire, Mendocino County, CA\", fontsize=13)\n",
        "ax.set_xlabel('Longitude (degrees)')\n",
        "ax.set_ylabel('Latitude (degrees)')\n",
        "plt.show()"
      ],
      "id": "4076110e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Both the false color imagery and the $RBR$ imagery provide ways to understand the scope and magnitude of fire across landscapes. But what if you were interested in understanding more detail about the area affected? For this, we'll turn to data on **land cover**.\n",
        "\n",
        "## Land Cover Statistics\n",
        "\n",
        "To understand what biomes and land cover types were affected by the fire, we'll access a different MPC collection: the [USGS Gap Land Cover data](https://www.usgs.gov/programs/gap-analysis-project/science/land-cover-vision). This data contains information on detailed information on land use and land cover (lulc) types that will let us get more information about the Mendocino Complex Fire's impact. One downside of this dataset is that it is from 2011, so it is fairly outdated. It also means we cannot compare land cover before and after the fire event in the same way as with the Landsat data. The biggest upside of the Gap collection, however, is its level of detail. This dataset contains much more finescale classification of land cover and land use types than some of the more general datasets present in the MPC catalog. So, for this example, we will use the Gap data to make an estimation of what the land cover was like in Mendocino County before the 2018 fire.\n"
      ],
      "id": "b0fd3309"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Open MPC data catalog\n",
        "catalog = pystac_client.Client.open(\n",
        "    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n",
        "    modifier=planetary_computer.sign_inplace,\n",
        ")\n",
        "\n",
        "# Search MPC catalog \n",
        "search = catalog.search(collections=['gap'], # Different collection than previous catalog search\n",
        "                        bbox=mendocino_bbox)\n",
        "\n",
        "# Retrieve search items\n",
        "items = search.item_collection()\n",
        "print(f\"Returned {len(items)} Items\")"
      ],
      "id": "5ac7a0df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Select unique search item\n",
        "item = items[0]  \n",
        "\n",
        "# Access raster data from item\n",
        "lulc = rioxr.open_rasterio(item.assets['data'].href)\n",
        "\n",
        "# Remove length 1 dimension (band)\n",
        "lulc = lulc.squeeze().drop_vars('band')\n",
        "print(\"Sizes of dimensions:\", dict(lulc.sizes))\n",
        "\n",
        "# Confirm CRS match\n",
        "lulc = lulc.rio.reproject(\"EPSG:4326\")\n",
        "assert lulc.rio.crs == mendocino.crs\n",
        "\n",
        "# Clip to fire perimeter\n",
        "lulc_clip = (lulc.rio.clip_box(*mendocino.total_bounds)\n",
        "                 .rio.clip(mendocino.geometry)\n",
        "                 )"
      ],
      "id": "c37ff898",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Get the number of pixels per class\n",
        "values, counts = np.unique(lulc_clip, return_counts = True)\n",
        "\n",
        "# Store values and counts in a dataframe\n",
        "pix_counts = pd.DataFrame({\n",
        "    'code' : values,\n",
        "    'pixel_count' : counts,\n",
        "})\n",
        "\n",
        "# Import the class labels dataset\n",
        "labels = pd.read_csv(os.path.join('data',\n",
        "                    'GAP_National_Terrestrial_Ecosystems.csv')\n",
        "                    )\n",
        "\n",
        "# Join the pixel count and labels dfs\n",
        "pix_label = pd.merge(pix_counts, labels, how=\"left\", on='code')"
      ],
      "id": "4a8b8aa9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Filtering out the 'no-data' class\n",
        "valid_classes = pix_label[pix_label['code'] != 65535].copy()\n",
        "\n",
        "# Find the total pixels to calculate land cover percentages\n",
        "total_pixels = valid_classes['pixel_count'].sum()\n",
        "\n",
        "# Calculate land cover percentage\n",
        "valid_classes['percentage'] = (valid_classes['pixel_count'] / total_pixels) * 100\n",
        "valid_classes = valid_classes[['class_label', 'percentage', 'pixel_count']].sort_values(by='percentage', ascending=False)"
      ],
      "id": "71a1630a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Reveal code\"\n",
        "\n",
        "# Plot the land cover statistics\n",
        "plt.figure(figsize=(12, 6))\n",
        "\n",
        "ax = sns.barplot(data=valid_classes.head(10), # Only interested in the top 10 most common classes\n",
        "                y='class_label',  \n",
        "                x='percentage',\n",
        "                color='#40A135',\n",
        "                edgecolor='black',\n",
        "                orient='h'\n",
        "                )\n",
        "\n",
        "# Add values on top of the bars\n",
        "for container in ax.containers:\n",
        "    ax.bar_label(container, padding=5, fmt='%.1f%%')  \n",
        "\n",
        "# Format x-axis tick labels\n",
        "ax.xaxis.set_major_formatter(mtick.PercentFormatter(xmax=100, decimals=0))\n",
        "# Add x-axis gridlines\n",
        "ax.set_axisbelow(True) # Set below the bars\n",
        "ax.xaxis.grid(True, which='major', linestyle='--', color='lightgrey')\n",
        "\n",
        "# Format y-ticks\n",
        "yticks = list(range(10))  # Added to avoid userwarning setting ytick labels\n",
        "ax.set_yticks(yticks)\n",
        "ax.set_yticklabels([\n",
        "    'Mediterranean California Dry-Mesic\\nMixed Conifer Forest and Woodland',\n",
        "    'Northern and Central California\\nDry-Mesic Chaparral',\n",
        "    'California Lower Montane Blue\\nOak-Foothill Pine Woodland and Savanna',\n",
        "    'California Central Valley Mixed Oak Savanna',\n",
        "    'California Xeric Serpentine Chaparral',\n",
        "    'Introduced Upland Vegetation\\n- Annual Grassland',\n",
        "    'Developed, Open Space',\n",
        "    'California Coastal Live Oak\\nWoodland and Savanna',\n",
        "    'California Northern Coastal Grassland',\n",
        "    'Harvested Forest-Shrub Regeneration'\n",
        "])\n",
        "\n",
        "# Remove plot borders for clarity\n",
        "ax.spines['top'].set_visible(False)\n",
        "ax.spines['right'].set_visible(False)\n",
        "\n",
        "# Title and labels\n",
        "ax.set_title('Distribution of Land Cover within the Ranch Fire Perimeter\\n(2011 USGS National Terrestrial Ecosystems Data)', fontsize=13)\n",
        "ax.set_xlabel('')\n",
        "ax.set_ylabel('')\n",
        "plt.yticks(fontsize=11)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "ccc3ca7a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Examining Relative Burn Ratio Across Land Cover Types\n",
        "Now that we've looked at both RBR and Land Cover separately, let's combine these two datasets two understand which vegetation types may be proportionally seeing an increased RBR.\n",
        "\n",
        "Before combining our data, we'll start by ensuring our CRS, shape, and resolution match between the two datasets. \n"
      ],
      "id": "4809c15c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Check the CRS and shape\n",
        "print(\"RBR CRS:\", rbr.rio.crs)\n",
        "print(\"LULC CRS:\", lulc_clip.rio.crs)\n",
        "\n",
        "print(\"RBR shape:\", rbr.shape)\n",
        "print(\"LULC shape:\", lulc_clip.shape)\n",
        "\n",
        "# Our shapes don't match, so let's resample the lulc to match the rbr\n",
        "lulc_resampled = lulc_clip.rio.reproject_match(rbr, resampling=rasterio.enums.Resampling.nearest)\n",
        "\n",
        "print(\"\\nAfter resampling:\")\n",
        "print(\"RBR shape:\", rbr.shape)\n",
        "print(\"LULC shape:\", lulc_resampled.shape)"
      ],
      "id": "18208fb0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Add a final check to ensure things are good before proceeding\n",
        "assert rbr.rio.crs == lulc_resampled.rio.crs\n",
        "assert rbr.shape == lulc_resampled.shape"
      ],
      "id": "f5542e2c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Extract data values\n",
        "rbr_values = rbr.values\n",
        "lulc_values = lulc_resampled.values\n",
        "\n",
        "# Create masks for valid data (non-NaN RBR and non-zero LULC)\n",
        "valid_rbr = ~np.isnan(rbr_values) # ~ represents NOT\n",
        "valid_lulc = lulc_values != 0\n",
        "combined_mask = valid_rbr & valid_lulc\n",
        "\n",
        "# Extract only the pixels within the combined mask\n",
        "rbr_mask = rbr_values[combined_mask]\n",
        "lulc_mask = lulc_values[combined_mask]\n",
        "\n",
        "# Create a combined df of rbr and lulc\n",
        "combined_df = pd.DataFrame({\n",
        "    'rbr': rbr_mask,\n",
        "    'lulc_code': lulc_mask.astype(int)\n",
        "})\n",
        "\n",
        "# Merge with class labels\n",
        "combined_analysis = pd.merge(combined_df, labels, left_on='lulc_code', right_on='code', how='left')"
      ],
      "id": "d1ecab5c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Calculate RBR stats by land cover type\n",
        "rbr_by_landcover = combined_analysis.groupby('class_label')['rbr'].agg([\n",
        "    'count', 'mean', 'median', 'std', 'min', 'max'\n",
        "])\n",
        "\n",
        "# Add percentage of total area\n",
        "rbr_by_landcover['percentage'] = (rbr_by_landcover['count'] / rbr_by_landcover['count'].sum() * 100).round(2)\n",
        "\n",
        "# Sort by median RBR \n",
        "rbr_by_landcover = rbr_by_landcover.sort_values('median', ascending=False)\n",
        "\n",
        "# Filter for land cover types greater than 1% of fire area\n",
        "significant_types = rbr_by_landcover[rbr_by_landcover['percentage'] > 1.0]"
      ],
      "id": "eaa2716f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that we've combined our $RBR$ and lulc data, let's make maps to visualize the land cover types with the highest average $RBR$ values and land cover types with the lowest average $RBR$ values.\n"
      ],
      "id": "59bc387e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Extract color map\"\n",
        "\n",
        "# Access the colormap associated with the Gap data\n",
        "with rasterio.open(item.assets[\"data\"].href) as dataset:\n",
        "    colormap = dataset.colormap(1)\n",
        "\n",
        "# Extract the colormap keys, these correspond to a land cover class\n",
        "keys = list(colormap.keys()) \n",
        "keys.sort()\n",
        "\n",
        "# Confirm that every unique color map key was extracted\n",
        "assert keys == list(range(0, len(keys)))  \n",
        "\n",
        "# Convert colors to RGBA format that works with matplotlib \n",
        "color_list = []\n",
        "for key in keys:  \n",
        "    rgba = colormap[key] \n",
        "    # Rasterio colors are 0-255 but matplotlob needs 0-1 \n",
        "    normalized_color = [float(v) / float(255) for v in rgba]\n",
        "    color_list.append(normalized_color)\n",
        "\n",
        "# Create a discrete colormap from the converted colors\n",
        "cmap_lulc = ListedColormap(color_list)\n",
        "\n",
        "# --------- High severity ----------\n",
        "\n",
        "# Extract the class labels of the 5 most severe and least severe rbr land cover types \n",
        "high_rbr_types = rbr_by_landcover.head(5).index\n",
        "\n",
        "# Filter by those class names to get entire df\n",
        "rbr_index = rbr_by_landcover.reset_index()\n",
        "high_rbr_df = rbr_index[rbr_index['class_label'].isin(high_rbr_types)]\n",
        "\n",
        "# Join class codes back on so we can pull the associated colormap\n",
        "high_rbr_code = pd.merge(high_rbr_df, labels, how='left', on='class_label')\n",
        "\n",
        "# Get unique values\n",
        "high_unique = np.unique(high_rbr_code['code'])\n",
        "# Add the no-data class back\n",
        "high_unique = np.insert(high_unique, 0, 0)\n",
        "\n",
        "# Create a subset colormap and class labels for values in clipped data\n",
        "high_colors = [cmap_lulc.colors[v] for v in high_unique]\n",
        "high_cmap = ListedColormap(high_colors)\n",
        "high_classes = item.properties[\"label:classes\"][0][\"classes\"]\n",
        "\n",
        "# Create patches for clipped data\n",
        "high_patches = []\n",
        "for i, v in enumerate(high_unique):\n",
        "    if v < len(high_classes):\n",
        "        high_patches.append(Patch(color=high_colors[i], label=high_classes[v]))\n",
        "    else: \n",
        "        # Fallback in case a class is outside the chosen subset classes, label as class #\n",
        "        high_patches.append(Patch(color=high_colors[i], label=f'Class {v}'))\n",
        "\n",
        "\n",
        "# --------- Low severity ----------\n",
        "\n",
        "# Extract the class labels of the 5 most severe and least severe rbr land cover types \n",
        "low_rbr_types = rbr_by_landcover[rbr_by_landcover['percentage'] > 1.0].tail(5).index\n",
        "\n",
        "# Filter by those class names to get entire df\n",
        "low_rbr_df = rbr_index[rbr_index['class_label'].isin(low_rbr_types)]\n",
        "\n",
        "# Join class codes back on so we can pull the associated colormap\n",
        "low_rbr_code = pd.merge(low_rbr_df, labels, how='left', on='class_label')\n",
        "\n",
        "# Get unique values\n",
        "low_unique = np.unique(low_rbr_code['code'])\n",
        "# Add the no-data class back\n",
        "low_unique = np.insert(low_unique, 0, 0)\n",
        "\n",
        "# Create a subset colormap and class labels for values in clipped data\n",
        "low_colors = [cmap_lulc.colors[v] for v in low_unique]\n",
        "low_cmap = ListedColormap(low_colors)\n",
        "# Get class labels from stac metadata\n",
        "low_classes = item.properties[\"label:classes\"][0][\"classes\"]\n",
        "\n",
        "# Create patches for clipped data\n",
        "low_patches = []\n",
        "for i, v in enumerate(low_unique):\n",
        "    if v < len(low_classes):\n",
        "        low_patches.append(Patch(color=low_colors[i], label=low_classes[v]))\n",
        "    else:\n",
        "\n",
        "        low_patches.append(Patch(color=low_colors[i], label=f'Class {v}'))"
      ],
      "id": "8afc047e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: \"Reveal code\"\n",
        "# Initialize figure\n",
        "fig, axes = plt.subplots(2, 1, figsize=(14, 12))\n",
        "\n",
        "# --------- High severity ----------\n",
        "\n",
        "# Map the most severe data value to the subset colormap indices\n",
        "# Need to remap the values here because color maps expect sequential values, not the random numbers of lulc codes\n",
        "high_mapped = np.zeros_like(lulc_clip)\n",
        "for i, v in enumerate(high_unique):\n",
        "    high_mapped[lulc_clip == v] = i\n",
        "\n",
        "# Convert mapped data to color array for visualization\n",
        "high_data = np.moveaxis(\n",
        "    # Apply colormap to the remapped data\n",
        "    # Rearrange the dimensions of the array becase rasterio.show() expects a different order\n",
        "    high_cmap(high_mapped), [0, 1, 2], [1, 2, 0] # 0: height, 1: width, 2: color_channels\n",
        ")\n",
        "                \n",
        "# Plot the data using rasterio.show\n",
        "# returns a matplotlib object that doesn't need to be assigned to something, so assign it to '-'\n",
        "_ = show(high_data, ax=axes[0], transform=lulc_clip.rio.transform(), interpolation=\"none\")\n",
        "\n",
        "# Add the fire boundary\n",
        "mendocino.boundary.plot(ax=axes[0], color='red', linewidth=2)\n",
        "\n",
        "axes[0].legend(handles=high_patches, bbox_to_anchor=(1, 1), loc='upper left')\n",
        "axes[0].set_title(f'Highest Median RBR Land Cover Types')\n",
        "\n",
        "\n",
        "# --------- Low severity ----------\n",
        "\n",
        "# Map the least severe data value to the subset colormap indices\n",
        "low_mapped = np.zeros_like(lulc_clip)\n",
        "for i, v in enumerate(low_unique):\n",
        "    low_mapped[lulc_clip == v] = i\n",
        "\n",
        "# Convert mapped data to color array for visualization\n",
        "low_data = np.moveaxis(\n",
        "    low_cmap(low_mapped), [0, 1, 2], [1, 2, 0]\n",
        ")\n",
        "                \n",
        "# Plot the data using rasterio.show\n",
        "_ = show(low_data, ax=axes[1], transform=lulc_clip.rio.transform(), interpolation=\"none\")\n",
        "\n",
        "# Add the fire boundary\n",
        "mendocino.boundary.plot(ax=axes[1], color='red', linewidth=2)\n",
        "\n",
        "axes[1].legend(handles=low_patches, bbox_to_anchor=(1, 1), loc='upper left')\n",
        "axes[1].set_title(f'Lowest Median RBR >1% Land Cover Types')\n",
        "plt.show()"
      ],
      "id": "237a6e09",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(f\"High severity land cover types\")\n",
        "for idx, row in high_rbr_code.iterrows():\n",
        "    print(f\"\\n{row['class_label']}\")\n",
        "    print(f\"Median RBR: {row['median']:.4f}\")\n",
        "    print(f\"Area affected: {row['percentage']:.2f}%\")"
      ],
      "id": "14ebebfe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "print(f\"Low severity land cover types\")\n",
        "\n",
        "for idx, row in low_rbr_code.iterrows():\n",
        "    print(f\"\\n{row['class_label']}\")\n",
        "    print(f\"Median RBR: {row['median']:.4f}\")\n",
        "    print(f\"Area affected: {row['percentage']:.2f}%\")"
      ],
      "id": "6d6b3bc5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Conclusion\n",
        "\n",
        "As you can see, land cover type varies across which regions of the fire had more or less severe burn ratios. Various characteristics such as slope, aspect, humidity, and more affect both the vegetative composition of a microsite, but also that particular site's risk of high or low severity fire. Understanding the parameters associated with fire risk and severity is a delicate balance, one that especially is less well understood in non-forested ecosystems such as oak woodlands. \n",
        "\n",
        "\n",
        "#### References\n",
        "- California Department of Forestry and Fire Protection (CAL FIRE), calfire_all.gdb, 2024-11-17, retrieved from [CAL FIRE data portal.](https://www.fire.ca.gov/what-we-do/fire-resource-assessment-program/fire-perimeters)\n",
        "- Earth Resources Observation and Science (EROS) Center. (2020). Landsat 8-9 Operational Land Imager / Thermal Infrared Sensor Level-2, Collection 2. U.S. Geological Survey. https://doi.org/10.5066/P9OGBGM6\n",
        "- A. Davidson and A. McKerrow, “GAP/LANDFIRE National Terrestrial Ecosystems 2011.” U.S. Geological Survey, 2016. doi: 10.5066/F7ZS2TM0. Available: https://www.sciencebase.gov/catalog/item/573cc51be4b0dae0d5e4b0c5. [Accessed: Nov. 26, 2024]"
      ],
      "id": "6e38a1fe"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}